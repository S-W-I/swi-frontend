{
  "sc": "\nuse byteorder::{ByteOrder, LittleEndian};\nuse solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint,\n    entrypoint::ProgramResult,\n    msg,\n    program_error::ProgramError,\n    pubkey::Pubkey,\n};\n// use solana_sdk::system_instruction::SystemInstruction;\nuse std::mem;\n\n// Declare and export the program's entrypoint\nentrypoint!(process_instruction);\n\n// Program entrypoint's implementation\npub fn process_instruction(\n    program_id: &Pubkey, // Public key of the account the hello world program was loaded into\n    accounts: &[AccountInfo], // The account to say hello to\n    _instruction_data: &[u8], // Ignored, all helloworld instructions are hellos\n) -> ProgramResult {\n    msg!(\"Helloworld Rust program entrypoint\");\n\n    // Iterating accounts is safer then indexing\n    let accounts_iter = &mut accounts.iter();\n\n    // Get the account to say hello to\n    let account = next_account_info(accounts_iter)?;\n\n    // The account must be owned by the program in order to modify its data\n    if account.owner != program_id {\n        msg!(\"Greeted account does not have the correct program id\");\n        return Err(ProgramError::IncorrectProgramId);\n    }\n\n    // The data must be large enough to hold a u32 count\n    if account.try_data_len()? < mem::size_of::<u32>() {\n        msg!(\"Greeted account data length too small for u32\");\n        return Err(ProgramError::InvalidAccountData);\n    }\n\n    // Increment and store the number of times the account has been greeted\n    let mut data = account.try_borrow_mut_data()?;\n    let mut num_greets = LittleEndian::read_u32(&data);\n    num_greets += 1;\n    LittleEndian::write_u32(&mut data[0..], num_greets);\n\n    msg!(\"Hello!\");\n\n    Ok(())\n}\n\n// Sanity tests\n#[cfg(test)]\nmod test {\n    use super::*;\n    use solana_program::clock::Epoch;\n\n    #[test]\n    fn test_sanity() {\n        let program_id = Pubkey::default();\n        let key = Pubkey::default();\n        let mut lamports = 0;\n        let mut data = vec![0; mem::size_of::<u32>()];\n        LittleEndian::write_u32(&mut data, 0);\n\n        let owner = Pubkey::default();\n        let account = AccountInfo::new(\n            &key,\n            false,\n            true,\n            &mut lamports,\n            &mut data,\n            &owner,\n            false,\n            Epoch::default(),\n        );\n        let instruction_data: Vec<u8> = Vec::new();\n\n        let accounts = vec![account];\n\n        assert_eq!(LittleEndian::read_u32(&accounts[0].data.borrow()), 0);\n        process_instruction(&program_id, &accounts, &instruction_data).unwrap();\n        assert_eq!(LittleEndian::read_u32(&accounts[0].data.borrow()), 1);\n        process_instruction(&program_id, &accounts, &instruction_data).unwrap();\n        assert_eq!(LittleEndian::read_u32(&accounts[0].data.borrow()), 2);\n    }\n}\n"
}
